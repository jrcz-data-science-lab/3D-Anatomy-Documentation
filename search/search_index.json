{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Hello, welcome to the docuementation for the 3D-Anatomy-Project build by JRCZ Data Science Lab</p>"},{"location":"#general-overview","title":"General overview","text":"<p>The project itself is devided into several repositories</p> <ul> <li>3D Unreal Engine application GitHub</li> <li>Quiz, Django web application GitHub</li> <li>Frontend for model taggin, Django web application GitHub</li> <li>Python script for importing the Blender models to the Unreal Engine GitHub</li> <li>Python script for generating JSON files that can be loaded in Model taggin application GitHub </li> <li>This docuementation GitHub</li> </ul>"},{"location":"about-project/","title":"About the Project","text":"<p>The project is designed for nursing students at HZ University of Applied Sciences, whose nursing department is located in Vlissingen.</p>"},{"location":"about-project/#anatomy","title":"Anatomy","text":"<p>Learning human anatomy can be challenging without the right resources. During lectures, teachers often use presentations to display different parts of the human body. </p> <p>However, the issue arises when they cannot manipulate the body parts as they wish. Instead, they must find static images from various angles, which is neither fast nor efficient.</p> <p>This application will streamline the teaching process for instructors and enhance the learning experience for students.</p> <p>The key benefit of using this Unreal Engine application is that the body model is fully interactive, allowing students to get a comprehensive understanding of the inner workings of the human body. </p> <p>Additionally, teachers can display organs, bones, arteries, and other anatomical structures from any angle they prefer.</p>"},{"location":"about-project/#learning","title":"Learning","text":"<p>As mentioned, students can use this application to practice their anatomy knowledge. It features an interactive quiz built within Unreal Engine. The quiz questions, provided by the teachers, are fetched via an API call to a website designed for creating such quizzes here.</p>"},{"location":"about-project/#our-goal","title":"Our Goal","text":"<p>Our goal is simple: to provide the most efficient way for teachers and students to gain knowledge about the human body and, in doing so, contribute positively to society.</p>"},{"location":"VirtualAnatomy/Introduction/","title":"Basic Information for Project Development","text":"<p>This part of the documentation will contain basic information one needs to know in order to carry on with the project.</p>"},{"location":"VirtualAnatomy/Introduction/#purpose","title":"Purpose","text":"<p>The purpose of the Unreal Engine application is to do what it does best: displaying 3D models with interactive frame rates.</p> <p>It consists of two main levels: Explorer Level and Quiz Level. In the Explorer Level, teachers and students can freely explore a fully loaded 3D model of the human body.</p> <p>In the Quiz Level, teachers and students\u2014primarily students\u2014can complete quizzes that are created by the teachers.</p>"},{"location":"VirtualAnatomy/Introduction/#setting-up","title":"Setting Up","text":"<p>To begin development of this application, you need Unreal Engine version 5.4, which can be found in the Epic Games Launcher.</p>"},{"location":"VirtualAnatomy/Introduction/#windows","title":"Windows","text":"<p>For Windows, you also need Visual Studio with the following workload items added:</p> <ul> <li>Game Development with C++</li> <li>.NET SDK (can be installed by enabling .NET desktop development)</li> </ul> <p>Once you have everything set up, you can launch the project by opening the <code>ThreeDAnatomy.uproject</code> file with Unreal Engine. </p> <p>To add the necessary files to open the project with Visual Studio, run <code>Tools &gt; Generate Visual Studio Project</code>. Then, open the project in Visual Studio by opening the generated <code>ThreeDAnatomy.sln</code> file.</p>"},{"location":"VirtualAnatomy/Introduction/#mac-os","title":"Mac OS","text":"<p>For Mac OS install Rider, and launch the project by opening the <code>ThreeDAnatomy.uproject</code> with Rider.</p>"},{"location":"VirtualAnatomy/Introduction/#linux","title":"Linux","text":"<p>For how to set up project up and running on Linux please reffer to this file </p>"},{"location":"VirtualAnatomy/Introduction/#c-code-guide-lines","title":"C++ code guide lines","text":"<p>For class members that have macro <code>UPROPERTY</code> or <code>UFUNCTION</code> defined above them we have used the <code>PascalCase</code></p> <p>For functions that are used inside classes we have also used <code>PascalCase</code></p> <p>For private member functions that are only accesible within the classes we have used <code>m_</code> prefix and <code>smallPacalCase</code> example</p> <pre><code>class FooBar{\n\npublic:\n    Foo(std::string name);\n\npublic:\n    UPROPERTY(BlueprintReadOnly)\n    AActor* actor\n\n    UFUNCTION(BlueprintCallable)\n    void DisplayFoo(bool&amp; success);\n\nprivate:\n    int m_countOfFoos;\n}\n\n</code></pre>"},{"location":"VirtualAnatomy/Introduction/#class-names","title":"Class names","text":"<p>Class names are specified with <code>PascalCase</code></p>"},{"location":"VirtualAnatomy/Introduction/#forward-declaration-of-headers","title":"Forward declaration of headers","text":"<p>In <code>C++</code> you can use <code>#include</code> prepocessor to include external header files. This however is going to take long time to compile, therefore we have used forward declaration wherever possible inside the header files and only use <code>#include</code> preprocessor inside the <code>cpp</code> files. </p>"},{"location":"VirtualAnatomy/Introduction/#memory-safety","title":"Memory safety","text":"<p>We have designed the class strucutre around <code>Ownership</code> priciple. To do that we have use <code>smart pointers</code>\u00a0that are defined by unreal engine. This assures that only given class can \"own\" the resource and others can only borrow it without additionaly coppies. </p>"},{"location":"VirtualAnatomy/Linux-set-up/","title":"Linux Set-Up","text":"<p>This guide will show you how to install unreal engine, compile required extension and get you up and running with the project</p>"},{"location":"VirtualAnatomy/Linux-set-up/#getting-unreal-engine","title":"Getting unreal engine","text":"<p>We have to compile unreal engine from source-code in order to use necessary plugins </p> <ol> <li>Visit unreal engine site and request their source code from this link they have a guide there how to do that</li> <li>Once you have the source code you can fork the repo and clone it directly to the desired directory on your compute, i suggest that you do it under <code>~/Software/</code></li> </ol> <pre><code>git clone &lt;repo url&gt;.git\n</code></pre> <ol> <li>When this is done go to the directory of the cloned game engine</li> </ol> <pre><code>cd ~/Software/UnrealEngine\n</code></pre> <ol> <li>Execute the following command to setup unreal engine for compilation</li> </ol> <pre><code>./Setup.sh\n</code></pre> <p>This should take couple of minutes</p> <ol> <li>Now execute another bash script to generate the project files </li> </ol> <pre><code>./GenerateProjectFiles.sh\n</code></pre> <ol> <li>Now run the make file to compile the engine </li> </ol> <pre><code>make\n</code></pre> <p>This takes around 2 hours so, you only have to wait</p> <ol> <li>After this is done you can execute Unreal Editor and select any template to see if everything works</li> </ol> <pre><code> cd ~/Software/UnrealEngine/Engine/Binaries/Linux\n ./UnrealEditor\n</code></pre>"},{"location":"VirtualAnatomy/Linux-set-up/#getting-jet-brains-rider","title":"Getting Jet Brains Rider","text":"<ol> <li>Download Jet Brains rider from this link  now go the the directory where <code>.tar.gz</code> file downloaded and execute following command </li> </ol> <pre><code>sudo tar -xzf Rider.tar.gz -C /opt\n</code></pre> <p>NOTE: the <code>Rider.tar.gz</code> can have various letters and strings after each, just change the file name to match the one you downloaded</p> <ol> <li>Navigate to <code>opt</code> directory and execute  the following commands</li> </ol> <pre><code>cd ./opt/JetBrains Rider-2024.2.3 #can be different version\n\n./Rider.sh\n</code></pre> <p>This will open your The jet brains rider, feel free to create desktop shortcut if you want from Tools -&gt; Create Desktop Entry</p>"},{"location":"VirtualAnatomy/Linux-set-up/#compiling-plugins","title":"Compiling plugins","text":"<ol> <li>Download the epic assets manager from the Flat hub</li> </ol> <pre><code>flatpak run io.github.achetagemes.epic_asset_manager\n</code></pre> <ol> <li>Open the epic assets manager and enter your epic login info.</li> <li>Open the market place in bottom left corner of the application </li> <li>Search for the <code>VaRest</code> plugin and Download it, it should be included in <code>~/Document/Epic Vault/VaRestPlugin_5.4</code></li> <li>Go to the <code>VaRestPlugin_5.4/data/Engine/Plugins/Marketplace/VaRestPlugin</code></li> <li>Open file <code>VaRest.uplugin</code> in any text editor and add <code>\"Linux\"</code> to the <code>PlatformAllowList</code>, if in the future plugins there is no modules add it there, this one should have it though</li> </ol> <pre><code>\"Modules\": [\n        {\n            \"Name\": \"VaRest\",\n            \"Type\": \"Runtime\",\n            \"LoadingPhase\": \"PreDefault\",\n            \"PlatformAllowList\":[\n                \"Linux\"\n            ]\n        },\n        {\n            \"Name\": \"VaRestEditor\",\n            \"Type\": \"UncookedOnly\",\n            \"LoadingPhase\": \"Default\",\n            \"PlatformAllowList\":[\n                \"Linux\"\n            ]\n        }\n</code></pre> <ol> <li>Make a copy of your Unreal Engine folder as it can broke to the point you would have to rebuild entire engine if we use it for the compilation of the plugin.</li> </ol> <pre><code>cd ~/Software\ncp UnrealEngin ./UnrealEngine-cpy -rrm \n</code></pre> <ol> <li>Navigate to the batch files of the copied engine and compile the plugin</li> </ol> <pre><code>cd ~/Software/UnrealEngine-cpy/Engine/Build/BatchFiles\n\n./RunUAT.sh BuildPlugin -Plugin=\"/home/name/Documents/EpicVault/VaRestPlugin_5.4/data/Engine/Plugins/Marke\ntplace/VaRestPlugin/VaRest.uplugin\" -Package=\"/home/name/Documents/EpicVault/VaRestPlugin_5-build\" -TargetPlatforms=Linux\n\n# package is the directory where you want the compiled plugin to be in\n</code></pre> <p>This will again take around 1 hour to compile </p> <p>Once it is done move the plugin from its compiled directory to the <code>~/Software/UnrealEngine/Engine/Plugins/Markteplace</code> if there is no market place directory create it </p> <p>In case of any issues of compiling the plugin refer to this video. </p> <p>If you can not start your unreal engine after you have done this or getting error that the some library is missing, you unfortunately must remove the engine and recompile it from scratch.</p>"},{"location":"VirtualAnatomy/Linux-set-up/#running-the-project","title":"Running the project","text":"<p>Now we can finally get to the project we are supposed to be running. Clone the project from the organisation's  repository.</p> <p>Now open the rider use it to open the file called  <code>ThreeDAnatomy.uproject</code> if you get errors that there is no engine associated with this project or that the project could not be loaded navigate to the  <code>~/.config/EpicGames/UnrealEngine</code> and use open <code>Install.ini</code>, there you should see something like this </p> <pre><code>[Installations]\n{61290131-F9C9-4A40-9CB3-202F4B612D47}=/home/name/Software/UnrealEngine\n</code></pre> <p>Add another line with following content</p> <pre><code>UE_5.4=/home/wpsimon09/Software/UnrealEngine\n</code></pre> <p>Now open the <code>ThreeDAnatomy.uproject</code> and change the <code>\"EngineAssociation\"</code> key to have the value of <code>5.4</code> </p> <pre><code>{\n        \"FileVersion\": 3,\n        \"EngineAssociation\": \"5.4\",\n        \"Category\": \"\",\n        \"Description\": \"\",\n//other stuff\n}\n</code></pre> <p>Now close the rider and reopen the <code>ThreeDAnatomy.uproject</code> with it, it might still display that it was not loaded but eventually after quite some time it should load it, the loading is signalised by the progress bars on the bottom left of Rider interface  </p> <p>Note that it loaded both the project and engine.</p> <p>![[Rider-interface-loaded-project-and-engine.png]]</p> <p>Now you have to build the project by right clicking on the <code>ThreeDAnatomy</code> and selecting <code>BuildSelectedProjects</code> </p> <p>IMPORTANT: Never select the option to build the solution as it will rebuild entire Unreal Engine together with it</p> <p>Once everything is build you can press play in top right corner (or debug) it will open the unreal editor where you can start working </p>"},{"location":"VirtualAnatomy/ExplorerLevel/AnatomyHelpers/","title":"Anatomy Helpers","text":"<p>This header file provides inline definitions of functions that help simplify the development process.</p> <p>These functions are declared and defined under the <code>AnatomyUtils</code> namespace.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/AnatomyHelpers/#inline-static-aactor-getactorbynamefstring-name-uworld-world","title":"<code>inline static AActor* GetActorByName(FString name, UWorld* world)</code>","text":"<p>Parameters:</p> <ul> <li><code>FString name</code> - The name of the actor to search for.</li> <li><code>UWorld* world</code> - The world in which to look for the actor.</li> </ul> <p>Returns:</p> <ul> <li><code>AActor*</code> - A pointer to the actor found. If the actor is not found, this function returns <code>nullptr</code> and a log message will inform you about the failure.</li> </ul> <p>This helper function will serach the provide world for the actor with the provided name </p>"},{"location":"VirtualAnatomy/ExplorerLevel/AnatomyHelpers/#inline-static-aactor-getrandomactoruworld-world","title":"<code>inline static AActor* GetRandomActor(UWorld* world)</code>","text":"<p>Parameters:</p> <ul> <li><code>UWorld* world</code> - The world in which to look for the actor.</li> </ul> <p>Returns:</p> <ul> <li><code>AActor*</code> - A pointer to the random actor from the world, if world contains no actors this function will </li> </ul>"},{"location":"VirtualAnatomy/ExplorerLevel/Animations/","title":"Animations","text":"<p>So far, all body parts that have been loaded are animated. All animations are stored in the <code>Body-Merged-Full/Animations</code> directory, which contains folders for each body part. These folders include various animation-related files. For example, in the <code>Body</code> folder, you will find the <code>Skeleton</code> for the bones mesh, the <code>Animation Blueprint</code>, and the <code>Level Sequence</code>.</p> <p>We have only rigged and animated the merged meshes that are displayed in the viewport.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Animations/#how-we-animated","title":"How We Animated","text":"<ol> <li> <p>Importing Merged Meshes:    We imported the merged meshes from Blender. Once imported, we right-clicked on the desired mesh and selected <code>Convert to Skeletal Mesh</code>. Note: If you don't see this option, enable the plugin by going to <code>Plugins -&gt; Skeletal Mesh Editing Tools</code>.</p> </li> <li> <p>Creating the Skeletal Mesh:    This conversion generated the skeletal mesh, which can then be rigged by placing bones and adjusting the weights of the mesh's vertices.    For more information on rigging, please refer to this video.</p> </li> <li> <p>Creating the Animation:    To animate the model, we created a sequencer by right-clicking inside the content browser.    It is important to load the skeleton (not the skeletal mesh) into the sequencer.</p> </li> <li> <p>Baking and Playing the Animation:    Once we were satisfied with the animation, we baked it into an animation asset. After that, we used the <code>Animation Blueprint</code> to play the animation.</p> </li> </ol>"},{"location":"VirtualAnatomy/ExplorerLevel/Animations/#naming-conventions-used","title":"Naming Conventions Used","text":"<ul> <li><code>SK_</code> prefix for skeletons.</li> <li><code>CamelCase</code> for baked animation sequences.</li> <li><code>SEQ_</code> prefix for sequencers.</li> <li><code>BPA_</code> prefix for animation blueprints.</li> </ul>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/","title":"Character","text":"<p>Here we will cover the basics, like how I can walk around the scene without actually seeing the camera, or how it is possible that I can rotate without finding the <code>OnUserClick</code> event.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#character_1","title":"Character","text":"<p>Since this is not a video game, we have named our character \"User.\"</p> <p>The character is what you would expect it to be: to walk around and interact with the level.</p> <p>The character is spawned at the player start location, which can be seen in the <code>World Explorer</code> menu on the right.</p> <p></p> <p>To specify which character is going to be spawned inside the level, we can open the <code>CPP_GameMode.cpp</code> file, and inside the constructor, we see this code:</p> <pre><code>static ConstructorHelpers::FClassFinder&lt;APawn&gt; PlayerPawnBP(TEXT(\"/Game/Blueprints/UserControls/BP_User\"));\n\n    if(PlayerPawnBP.Class != NULL)\n    {\n        DefaultPawnClass =  PlayerPawnBP.Class;\n        UE_LOG(LogTemp, Warning, TEXT(\"UserBP was set as default pawn class\"));\n    }else{\n        UE_LOG(LogTemp, Error, TEXT(\"UserBP was not found\"));\n    }\n</code></pre> <p>This code grabs the Blueprint of our user and assigns it to the Game Mode so that the Unreal Engine knows what character to spawn and which character will be \"possessed\" by the player. In other words, with this, we tell Unreal Engine that our character is going to be controlled by the user behind the computer.</p> <p>But wait, why do we have <code>BP_User</code> if we are using only C++?</p> <p>Well, this is for the ease of development. If you visit the path specified inside <code>FClassFinder</code>, you can see that the parent class of this <code>BP_User</code> is the <code>CPP_User</code>.</p> <p>With this approach, we can simply modify various parameters as we see fit without the additional hassle of C++.</p> <p>Since <code>BP_User</code> is inherited from <code>CPP_User</code>, it contains all of the information and actions as what is written in <code>CPP_User</code>.</p> <p>Now you might be wondering how I can see without any camera.</p> <p>This is covered in the following section.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#character-class-cpp_usercpp","title":"Character class (CPP_User.cpp)","text":"<p>This class inherits from <code>ACharacter</code>, which means that our player (user) is able to control the character and move it in the scene.</p> <p>Now we will walk you through the <code>CPP_User.h</code> file, which contains the definition of the <code>CPP_User</code> class.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#acpp_user","title":"<code>ACPP_User();</code>","text":"<p>Constructor of the class. Here we set up the camera together with the spring arm component to aid us with collisions with meshes and the floor.</p> <p>The camera and spring arm are created and added to the root component of the character using the following code:</p> <pre><code>    //for spring arm it is named camera boom as most of the Unreal Engine comunty gives this name to it \n    CameraBoom = CreateDefaultSubobject&lt;USpringArmComponent&gt;(TEXT(\"Camera Boom\"));\n\n    //add to the root of the player \n    CameraBoom-&gt;SetupAttachment(RootComponent);\n</code></pre> <p>The camera is created in similuar manner and is added as a child of <code>CameraBoom</code></p> <pre><code>    MainCamera =  CreateDefaultSubobject&lt;UCameraComponent&gt;(TEXT(\"Main camera\"));\n    MainCamera-&gt;SetupAttachment(CameraBoom,USpringArmComponent::SocketName);\n\n</code></pre> <p>If you visit the <code>BP_User</code> and open the viewport, you can see both the spring arm and camera there.</p> <p>NOTE: To see the viewport of the blueprint, you have to enable the full blueprint editor. It should prompt you to do so once you double-click on the <code>BP_User</code>.</p> <p></p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#public-fiels","title":"Public fiels","text":""},{"location":"VirtualAnatomy/ExplorerLevel/Character/#aactor-targetactor","title":"<code>AActor* TargetActor</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Target Actor\",meta = (AllowPrivateAccess = \"true\"))</code></p> <p>This is the invisible actor in the scene which specifies the target around which our camera orbits.</p> <p>This actor is moved around the model of the human body based on which part of the body was selected. See ActorSelector for more details.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#uspringarmcomponent-cameraboom","title":"<code>USpringArmComponent* CameraBoom;</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Camera)</code></p> <p>This pointer holds the spring arm component. Through this pointer, you can access it and manipulate it within the class.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#ucameracomponent-maincamera","title":"<code>UCameraComponent* MainCamera;</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Camera)</code></p> <p>This is the pointer to the actual camera that is going to be used for the player (user, in our case).</p> <p>Once you press the play button in the Unreal Editor, you will see what this camera sees. It is really that simple.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-beginplay","title":"<code>void BeginPlay()</code>","text":"<p>This is a function that is inherited from the <code>ACharacter</code>. It is overridden so that we can put anything we want to happen once you press the play button in the controller.</p> <p>For example, if you want the user to start spinning once the game starts, you would put it there.</p> <p>Here we set up our default <code>TargetActor</code> and <code>RayCaster</code>, since both of them require access to the <code>World</code>, and the <code>World</code> is not accessible during construction time (e.g., in the constructor).</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-tickfloat-deltatime","title":"<code>void Tick(float DeltaTime);</code>","text":"<p>Parameters:</p> <ul> <li><code>float DeltaTime:</code> - time between ticks, this parameter is provided by the Unreal Engine </li> </ul> <p>This is a function that is executed every <code>tick</code>. The tick frequency is usually every frame.</p> <p>The parameter <code>float DeltaTime</code> is the time in milliseconds between two tick functions.</p> <p>We use this function to store the delta time in order to make user movement frame rate independent.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#protected-fields","title":"Protected fields","text":""},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-zoomconst-finputactionvalue-value","title":"<code>void Zoom(const FInputActionValue&amp; Value)</code>","text":"<p>Parameters:</p> <p><code>float FInputActionValue&amp; Value:</code> - reference to the how much user has value passed by the enhanced input system </p> <p>This action gets executed once the user zooms in. The <code>FInputActionValue</code> is a reference to the amount that the user adjusted. This is handled through the Enhanced Input system of Unreal Engine.</p> <p>In other words, this function zooms the player either in or out in the scene based on how much they spun the mouse wheel or moved their fingers on the touchpad.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-lookconst-finputactionvalue-value","title":"<code>void Look(const FInputActionValue&amp; Value)</code>","text":"<p>Parameters:</p> <p><code>float FInputActionValue&amp; Value:</code> - reference to the how much user has value passed by the enhanced input system </p> <p>This function gets executed once the user turns around using their mouse, touchpad, or touch screen.</p> <p>To calculate the rotation of the actor, the function takes the position of the actor that we want to look at.</p> <p>It subtracts the player (user) position from the position of the <code>Target Actor</code> to get the direction pointing towards that target actor.</p> <p>We then normalize this direction to be of length 1.</p> <p>Next, we calculate how much the character (user) should rotate around this actor using <code>RotationDelta</code>. Once this is calculated, we construct a rotation matrix to perform the actual rotation.</p> <p>We apply this matrix to the calculated direction to get the new direction that the player is looking at.</p> <p>Lastly, we calculate the new position of the player (user) using this newly calculated direction.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-clickconst-finputactionvalue-value","title":"<code>void Click(const FInputActionValue&amp; Value);</code>","text":"<p>Parameters:</p> <p><code>float FInputActionValue&amp; Value:</code> - reference to the how much user has value passed by the enhanced input system </p> <p>This function is executed once per click.</p> <p>The value here should represent the position of the mouse in the <code>world space</code>; however, for some reason, it did not work as intended, so we used <code>Unproject</code> to calculate this value ourselves.</p> <p>This function also performs a ray cast to determine which actor the user clicked on (if any), sets the new position of the target actor to update where the camera should look, and highlights the selected mesh.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-setupplayerinputcomponentclass-uinputcomponent-playerinputcomponent","title":"<code>void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)</code>","text":"<p>Parameters:</p> <p><code>UInputComponent* PlayerInputComponent</code> - The input component to configure. This component holds the mappings of input actions and axes to function calls.</p> <p>This member function is inherited from the <code>ACharacter</code> class, and its main purpose is to tell Unreal Engine what functions should be executed once the user executes inputs specified by the Enhanced Input system.</p> <p>In other words, this function specifies that once the user moves the mouse in an arbitrary direction, the function <code>Look</code> will be executed. Similarly, when the user presses the right mouse button, the function <code>Click</code> will be executed.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#protected-member-fields","title":"Protected member fields","text":""},{"location":"VirtualAnatomy/ExplorerLevel/Character/#uinputmappingcontext-inputmapping","title":"<code>UInputMappingContext* InputMapping;</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"EnhancedInput\", meta = (AllowPrivateAccess = \"true\"))</code></p> <p>This is a variable that is configured in <code>BP_User</code> (inherited from <code>CPP_User</code>) and specifies what input mappings are going to be used for our user.</p> <p>This means it maps the keys that the user presses to the actions that are going to be executed. Refer to this video for more details.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#uinputaction-ia_rotate-ia_zoom-ia_click","title":"<code>UInputAction* IA_Rotate, IA_Zoom, IA_Click</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadOnly, Category= \"EnhancedInput\")</code></p> <p>These are the input actions that allow us to specify what actions our character can execute. Those fields are also configured inside the <code>BP_User</code> blueprint.</p> <p>The video linked above explains everything about the topic of the Unreal Engine enhanced input system.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#float-cameraspeed","title":"<code>float CameraSpeed</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera</code></p> <p>This is a simple float variable that defines the speed of the camera. This can also be changed inside the Unreal Editor.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#float-zoomspeed","title":"<code>float ZoomSpeed</code>","text":"<p><code>UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = Camera</code></p> <p>This is a simple float variable that defines the speed at which the user zooms to the currently set target.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#private-members","title":"Private members","text":""},{"location":"VirtualAnatomy/ExplorerLevel/Character/#float-m_deltatime","title":"<code>float m_deltaTime</code>","text":"<p>This variable represents the time before different ticks, used to achieve frame rate independent movement.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#tuniqueptrraycaster-m_raycaster","title":"<code>TUniquePtr&lt;RayCaster&gt; m_rayCaster</code>","text":"<p>This is a unique pointer for the ray caster class. The ray caster is used to determine which objects the user has clicked on.</p> <p>We have chosen to go with ray casting instead of pixel picking, as pixel picking requires another scene pass, which can be quite expensive given the complexity of the model.</p> <p>We use a unique pointer to enforce ownership and prevent memory leaks. See this blog post.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#tuniqueptrmeshselector-m_meshselector","title":"<code>TUniquePtr&lt;MeshSelector&gt; m_meshSelector</code>","text":"<p>Holds unique pointer to the <code>Mesh Selector</code> class</p> <p>The main purpose of this class is to highlihgt the objects that user has clicked on. See 4.MeshSelectoror</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-rotatearoundactorconst-fvector2d-lookinput","title":"<code>void RotateAroundActor(const FVector2D&amp; LookInput)</code>","text":"<p>Parameters:</p> <ul> <li><code>FVector2D&amp; LookInput</code> - how much should camera rotate</li> </ul> <p>Rotates the character around the <code>TargetActor</code> this method is being called inside the <code>Look</code> function to rotate the player</p>"},{"location":"VirtualAnatomy/ExplorerLevel/Character/#void-zoomtotheactorconst-float-lookinput","title":"<code>void ZoomToTheActor(const float&amp; LookInput)</code>","text":"<p>Parameters:</p> <ul> <li><code>const float&amp; LookInput</code> - how much should user move towards the target actor</li> </ul> <p>Moves user towards or backwards from the target actor based on the provided parameter.</p> <p>Parameter is extracted from the Enhanced input system.</p> <p>This function is called inside the <code>Zoom</code> method</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/","title":"First Glance at the Project","text":"<p>You have now entered the <code>Explorer Level</code> of the project and are probably wondering where you should even start. No worries, we\u2019ve got you covered.</p> <p>The scene you see loaded is in the <code>View Port</code>. This is where you can interact with different <code>Actors</code>, be it static meshes, post-processing volumes, and more.</p> <p>On the very right side, you see your <code>World Explorer</code>. This contains everything you see in the <code>View Port</code>, organized in folders. Each folder contains one or more <code>Scene Elements</code>, and each scene element contains one or more <code>Actors</code> that are displayed in your View Port, assuming they have something to display, like a <code>Static Mesh</code>.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#what-is-in-the-scene","title":"What Is in the Scene","text":""},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#folders-with-names-of-human-body","title":"Folders with Names of Human Body","text":"<p>Those folders contain exactly what you might imagine: scene components with the <code>Static Meshes</code> inside them. Each scene component represents a part of the model.</p> <p>For example, in the <code>Bones</code> directory, you can find a <code>Skull</code> sub-directory, and inside it, there are a lot of scene components that are static meshes, which contain the actual geometry and material of fragments of the human skull. Try to click on one to see where it is located in the <code>View Port</code>.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#content-browser","title":"Content Browser","text":"<p>On the very bottom of the Unreal Engine, you should see an icon with a folder; this is called the <code>Content Browser</code>. Here, all of the project files, assets, and <code>Blueprints</code> are located. This is what you can find there.</p> <pre><code> \u251c\u2500\u2500 Blueprints\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 InfoElements\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 UserControls\n\u251c\u2500\u2500 Collections\n\u251c\u2500\u2500 Developers\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 wpsimon09\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 Collections\n\u251c\u2500\u2500 Enums\n\u251c\u2500\u2500 Input\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 InputActions\n\u251c\u2500\u2500 Localization\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Game\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 en\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 nl-NL\n\u251c\u2500\u2500 Maps\n\u251c\u2500\u2500 Materials\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Body-Merged-Full\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Animations\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Body\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Hearth\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Lungs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Arteries\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Hearth\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Hearth\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 PapillaryMuscle\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Valves\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Lungs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Body-No-Material\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Arteries\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Hearth\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Lungs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ElementActions\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Outliner\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Slicer\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Full-Body-Organized\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Ear_Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Lower_Extremity_Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Lower_Extremity_Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Skull_Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Thoracic_Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Textures\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Upper_Extremity_Bones\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Vertebral_Column_Bones\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Full-body-test-all-in-one\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 HDRi\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Model\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Materials\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Heart\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ConductionSystem\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 CoronaryVessels\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 EpicardialFat\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Misc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Muscle\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 OutflowTract\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 PapillaryMuscle\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Lungs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 PulmonaryArteries\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 PulmonaryVeins\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 StaticMesh\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Heart\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 ConductionSystem\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 CoronaryVessels\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 EpicardialFat\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Misc\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Muscle\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 OutflowTract\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 PapillaryMuscle\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Valves\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 Lungs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 PulmonaryArteries\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 PulmonaryVeins\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Textures\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 Heart\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 CoronaryVessels\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u251c\u2500\u2500 Muscle\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2502\u00a0\u00a0 \u2514\u2500\u2500 OutflowTract\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u251c\u2500\u2500 Lungs\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 PulmonaryVeins\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 TestSkeleton\n\u251c\u2500\u2500 Python\n\u251c\u2500\u2500 Stereo3D_VitalVolkov\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Blueprints\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Input\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Actions\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 Materials\n\u251c\u2500\u2500 Tests\n\u2514\u2500\u2500 UI\n    \u251c\u2500\u2500 Assets\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 ButtonAssets\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 General\n    \u251c\u2500\u2500 Components\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Quiz\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 Questions\n    \u251c\u2500\u2500 FloatingWindows\n    \u251c\u2500\u2500 Fonts\n    \u251c\u2500\u2500 Icons\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Element\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Mouse\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 Sidebar\n    \u251c\u2500\u2500 Images\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 LocationWidget\n    \u251c\u2500\u2500 Islands\n    \u251c\u2500\u2500 LevelUI\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 ExplorerLevelUI\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 Sidebars\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 QuizLevelUI\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 Sidebars\n    \u251c\u2500\u2500 Menus\n    \u2514\u2500\u2500 ReusableButtons\n</code></pre> <p>That is a lot of directories, right? Let's walk through them really superficially to get a basic idea of what is going on.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#blueprints","title":"Blueprints","text":"<p>Here, all of the Blueprints are located. You can find the Blueprints for the User that can walk around (inside the <code>UserControls</code> folder) in the scene once the simulation is started (we will talk about this later).</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#developers","title":"Developers","text":"<p>Here, each developer can store their personalized assets. Nothing should be here unless you want to hide something from your colleagues.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#enums","title":"Enums","text":"<p>This folder contains Enums to differentiate between parts of the model, like the skull, muscles, heart, etc.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#input","title":"Input","text":"<p>This directory contains inputs and input mappings utilizing the Unreal Engine Enhanced Input system.</p> <p>In short, all user actions are defined here. A simple example of such an action is pressing <code>Space</code> to jump.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#maps","title":"Maps","text":"<p>Here we store different levels that users can visit during their time spent in the application.</p> <p>Levels are independent of each other and are exactly like levels in any video game.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#materials","title":"Materials","text":"<p>This folder should ideally be renamed to <code>Assets</code> instead of <code>Materials</code>, but for now, it remains as is.</p> <p>In short, this folder contains all the meshes, textures, materials, and HDRIs used in the levels.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#materialsbody-merged-full","title":"Materials/Body-Merged-Full","text":"<p>This subfolder contains all the merged body parts such as the heart, bones, and lungs. Additionally, you will also find the <code>Animations</code> folder here, which, as the name suggests, contains all the animations.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#materialsbody-no-materials","title":"Materials/Body-No-Materials","text":"<p>This subfolder contains individual meshes used for selecting specific parts of the body.</p> <p>NOTE: When you change an asset here, it will not be updated inside the View Port and World Explorer.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#python","title":"Python","text":"<p>Plain and simple, here are all of the Python scripts used only inside the engine.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#steredo3d_vitalvolkov","title":"Steredo3D_VitalVolkov","text":"<p>This is from developers before us and contains the ability to see the model in 3D (yes, with 3D glasses) only if your monitor supports it. This feature has not been used so far, so you can experiment with it.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#test","title":"Test","text":"<p>This is pretty self-explanatory.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#ui","title":"UI","text":"<p>Here you can find all of the widget Blueprints. In other words, every UI component, like buttons, menus, main pages, etc., can be found and edited here.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/FirstSteps/#virtual-anatomy","title":"Virtual anatomy","text":"<p>In this directory is the main source code of the entire application. Here you can find another subdirectory, <code>C++</code>, which contains the actual C++ code.</p> <p>Public</p> <p>Here are all of the header files containing definitions of classes, methods, and macros.</p> <p>Private</p> <p>This directory contains all of the definitions for the header files (.cpp).</p> <p>Some header files (and cpp files) are not visible through the Unreal Editor interface (like <code>CPP_RayCaster</code>, <code>CPP_ObjectSelector</code>), but some are, like <code>CPP_User</code>. This is because the class <code>CPP_RayCaster</code> does not inherit from any of the Engine's classes like <code>UObject</code> or <code>AActor</code>. To see those \"hidden\" files, please open the file in Visual Studio, JetBrains Rider, VSCode, or any other IDE or code editor you prefer.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/","title":"Mesh Selector","text":"<p>When the user clicks on a mesh, it gets highlighted. This class is responsible for determining which actor should be highlighted and which should not.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#how-is-highlighting-done","title":"How is Highlighting Done?","text":"<p>Highlighting different elements is achieved using a post-processing volume that spans the entire scene.</p> <p>This post-processing volume uses the <code>HighLightMat</code> material, which can be found in <code>Content\\Materials/</code>. To understand the process better, refer to this video.</p> <p>Every actor that has the <code>RenderCustomDepth</code> field set to <code>True</code> will be highlighted. By default, this field is set to <code>False</code>. We use this to our advantage by setting the <code>RenderCustomDepth</code> field to <code>True</code> whenever the user clicks on a mesh. This causes the clicked actor to be highlighted.</p> <p>To improve performance, we've merged larger parts of the model (like bones, arteries and parts of hearth) in Blender, allowing us to render them all at once. You can find these in the <code>Body-Merged-Full</code> folder in the context menu. This helped us load all necessary textures without the hassle of exporting FBX files properly. As a result, Blender scripts used by previous developers are no longer needed.</p> <p>To allow users to click on different parts of the model, we exported each body mesh as it is in the Blender file, but with fewer triangles using Blender's Decimate modifier.</p> <p>We then hid these meshes, so they're loaded into Unreal Engine's Bounding Volume Hierarchy but not drawn. These hidden meshes (static mesh actors) are named <code>Body-Full-Picker</code>. This lets us detect clicks on different parts of the model without rendering them, which gave us a huge performance boost.</p> <p>By default, the actors in Picker-Mesh are hidden and only become visible if the user selects them (clicks on them).</p> <p>While this approach may cause more work for developers, it significantly improves the user experience.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#meshselectorh","title":"<code>MeshSelector.h</code>","text":"<p>This class is responsible for performing the actions specified above.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#public-methods","title":"Public methods","text":""},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#meshselector","title":"<code>MeshSelector()</code>","text":"<p>The constructor of this class is empty as no parameters need to be passed during instantiation.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#void-highlightactoraactor-actor","title":"<code>void HighlightActor(AActor* actor)</code>","text":"<p>Parameters:</p> <ul> <li><code>AActor* actor</code> - The actor that was clicked and should be highlighted.</li> </ul> <p>This function highlights the actor passed as the parameter and de-highlights the actor that was previously highlighted.</p> <p>Additionally, it stores the previously highlighted actor inside <code>m_previouslySelectedActor</code> for future reference.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#void-deselectallactors","title":"<code>void DeselectAllActors()</code>","text":"<p>Deselets all of the actors that were hightlighted </p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#private-members","title":"Private Members","text":""},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#aactor-m_currentlyselectedactor","title":"<code>AActor* m_currentlySelectedActor</code>","text":"<p>The actor that is currently highlighted. By default, this is set to <code>nullptr</code> or is <code>nullptr</code> when nothing is selected.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#aactor-m_previouslyselectedactor","title":"<code>AActor* m_previouslySelectedActor</code>","text":"<p>The actor that was previously highlighted. By default, this is set to <code>nullptr</code> or is <code>nullptr</code> when nothing is selected.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#private-methods","title":"Private Methods","text":""},{"location":"VirtualAnatomy/ExplorerLevel/MeshSelector/#void-setactorhighlightvisibleaactor-actor-bool-ishighlightvisible","title":"<code>void SetActorHighlightVisible(AActor* actor, bool isHighlightVisible)</code>","text":"<p>Parameters:</p> <ul> <li> <p><code>AActor* actor</code> - The actor on which the highlight should be visible or hidden.</p> </li> <li> <p><code>bool isHighlightVisible</code> - Determines whether the highlight should be visible or hidden for this actor. <code>true</code> if the highlight should be visible, <code>false</code> otherwise.</p> </li> </ul> <p>Helper function that is setting the value <code>RenderCustomDepth</code> for the actor passed as the parameter </p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/","title":"Ray Caster","text":"<p>NOTE: This class cannot be seen inside the Unreal Editor as it does not inherit any of the classes provided by Unreal Engine. Its main purpose is to abstract away the ray casting logic.</p> <p>As mentioned, we have chosen ray casting as the primary method for selecting which objects the user clicks on.</p> <p>The way it works is that when the user clicks on the screen, we receive coordinates about where the mouse was clicked (in screen space). We then transform this mouse location to world space and calculate the direction from our character to the point where the mouse clicked. This direction is normalized, meaning it has a length of 1.</p> <p>Next, we specify a ray length parameter to determine where the ray should end.</p> <p>After that, we shoot the ray from the position of our character towards the calculated end of the ray.</p> <p>All of these calculations are performed once the user presses the left mouse button.</p> <p>As you might imagine, all of this is happening in the <code>Click</code> event inside the <code>CPP_User</code> class.</p> <p>The main responsibility of the <code>RayCaster</code> class is to trace the actual rays through the scene.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#raycasterh","title":"<code>RayCaster.h</code>","text":""},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#public-mehtods","title":"Public mehtods","text":""},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#raycasteruworld-world-nullptr","title":"<code>RayCaster(UWorld* world = nullptr)</code>","text":"<p>Parameters:</p> <ul> <li><code>UWorld* world</code> - world to use for ray casting  </li> </ul> <p>The constructor takes a world as a parameter, which can be <code>nullptr</code> by default since the \"world\" does not exist during construction time.</p> <p>However, you can construct this class in other places besides constructors.</p> <p>This decision gives you the flexibility to do so.</p> <p>The world is used to receive data from the scene so that we can test for the intersection with the ray.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#void-addignoredactoraactor-actortoignore","title":"<code>void AddIgnoredActor(AActor* actorToIgnore);</code>","text":"<p>Parameters:</p> <ul> <li><code>AActor* actorToIgnore</code> - pointer to the actor that you want to ignore </li> </ul> <p>Ignores the actor provided as the parameter. The parameter accepts a pointer to the actor.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#void-addignoredactorfstring-nameofactortoignore","title":"<code>void AddIgnoredActor(FString nameOfActorToIgnore);</code>","text":"<p>Parameters:</p> <ul> <li><code>FString nameOfActorToIgnore</code> - name of the actor that you want to get ignored </li> </ul> <p>Ignores the actor provided as the parameter. The parameter accepts the name of the actor. The name of this actor is looked up in the world and ignored. If the actor is not found, a message in the log will inform you about this.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#void-setworlduworld-world","title":"<code>void SetWorld(UWorld *world)</code>","text":"<p>Parameters:</p> <ul> <li><code>UWorld\u00a0*world</code> - world to be set</li> </ul> <p>Sets the current world that is going to be used during intersection testing. This will overwrite any other stored world inside the <code>m_world</code> member.</p> <p>This setter was chosen to preserve OOP principles and allow for the construction of this class during the construction time, during which the world is not available.</p> <p>Therefore, before each intersection test, you must ensure that the world is set correctly.</p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#bool-tracelinefvector-start-fvector-raydirection-float-raylength-1000","title":"<code>bool TraceLine(FVector start, FVector rayDirection, float rayLength = 1000)</code>","text":"<p>Parameters:</p> <ul> <li><code>FVector start</code> - The starting point of the ray in world space.</li> <li><code>FVector rayDirection</code> - The direction in which the ray will travel.</li> <li><code>float rayLength</code> - The length of the ray, default value is 1000.</li> </ul> <p>Returns:</p> <ul> <li><code>True</code> if a hit was detected.</li> <li><code>False</code> otherwise.</li> </ul> <p>This function uses the <code>LineTraceSingleByChannel</code> method from the <code>UWorld</code> class to trace the provided ray through the world. By default, it uses the Visible channel for intersection testing, meaning only objects that are visible within the scene will be tested for intersection.</p> <p>If a hit is detected, the actor that caused the intersection will be stored in the <code>m_currentHitActor</code>.</p> <p>Lastly, all actors that were added via <code>AddIngoredActor</code> method will be ignored</p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#private-members","title":"Private members","text":""},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#tarrayaactor-m_ignoredactors","title":"<code>TArray&lt;AActor*&gt; m_ignoredActors</code>","text":"<p>Array of the actors that are curretntly removed </p> <p>TODO: add method to delete actors from this array </p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#fvector-m_start","title":"<code>FVector m_start</code>","text":"<p>Start of the ray in the world space </p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#fvector-m_end","title":"<code>FVector m_End</code>","text":"<p>End of the ray in the world space </p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#uworld-m_world","title":"<code>UWorld* m_world</code>","text":"<p>World in which the ray casting and intersection testing will take place </p>"},{"location":"VirtualAnatomy/ExplorerLevel/RayCasting/#aactor-m_currenthitactor","title":"<code>AActor* m_currentHitActor</code>","text":"<p>Actor that was hit by the constructed ray. This is <code>nullptr</code> if no actor was hit.</p>"},{"location":"VirtualAnatomy/MainMenuLevel/LandingPage/","title":"Landing Page","text":"<p>For this part of the documentation, we will provide a brief overview of the design phases of the UI implementation for the Landing Page, as well as choices made along the way and how components function.</p> <p>The design of the application is based upon the figma design which can be seen here.</p> <p>First we set the new landing page to be used by the MainMenuLevel in the MainMenuLevel blueprint.</p> <p></p> <p>Withing the landing page, every element is anchored to the canvas panel. This is done in order to keep the application responsive. By anchoring elements to the canvas, they essentially stick to a certain chosen point on said canvas. In the following example, note that the \"Explorer Button\" is anchored to the center of the canvas (depicted by the flower looking icon).  (images/anchor-elements-example.png)</p>"},{"location":"VirtualAnatomy/MainMenuLevel/LandingPage/#ui-structure-and-resources","title":"UI Structure and Resources","text":"<p>All UI elements besides the Level components are kept in the UI directory.</p> <p>In order to match the Figma design, custom fonts are used which can be found in the \"Fonts\" directory.</p> <p></p> <p>A new directory for assets was created, named \"Assets\". This contains general assets such as design elements, as well as button assets acting as icons.</p>"},{"location":"VirtualAnatomy/MainMenuLevel/LandingPage/#reusable-buttons","title":"Reusable Buttons","text":"<p>For the sake of efficiency reusable buttons have been created.</p> <p>RectangleBase</p> <p>The rectangle base consists of three simple elements: overlay, button and text block, in that hierarchical order.</p> <p>To actually make this button reusable, it is necessary to declare the text block as a variable in the Designer tab of the UMG panel.</p> <p>In order to be able to edit the text for the button in the UMG panel, the event has to be pre-constructed. After which, with a simple setter function we get the previously assigned text variable named <code>txtDefault</code> and pass it into the setter function. Finally, we pass the <code>Text</code> variable with type <code>text</code> into the setter function so that we can dynamically chnage it.</p> <p></p> <p>Now that we have a reusable button, we simply navigate to our landing page's widget blueprint and search for our button underneath the <code>Palette</code> tab in UMG. Once we have added our button to the hierarchy, we can change the text to whatever we like from the <code>Details</code> tab.</p> <p>SquareBase</p> <p>The square base is very similar to the rectangle base in its hierarchy, the only change being that the text block is replaced with an image element in this case.</p> <p>In order to dynamically change the icons for our square base buttons, we create a custom event <code>SetButtonIcon</code> with an input of type <code>Texture 2D</code> named \"Icon Texture\". Next, we pass our event into a <code>Set Brush from Texture</code> node whose target is the image, followed by passing our icon texture input into the <code>Set Brush from Texture</code> node's <code>Texture</code>. Again we had to set the placeholder image inside the button as a variable so we can manipulate it. We get the image and pass that into the set brush node' target.</p> <p></p> <p>Now in our landing page, we can just simply drag the button into its hierarchy.</p> <p>In the landing page's blueprint we pre-construct again and call our <code>SetButtonIcon</code> event into which we pass our button as a target. Now we simply select the asset we would like to use once we have actually imported the asset.</p> <p></p>"}]}